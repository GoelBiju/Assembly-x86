; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25508.2 

	TITLE	C:\Users\goelm\Desktop\Assembler in Vísual Studio - Perfect Numbers CW\Assembler in Vusial Studio - Perfect Numbers CW\Start of stars CW\Perfect Numbers CW.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?numberFactor@@3HA				; numberFactor
PUBLIC	?divisionQuotient@@3HA				; divisionQuotient
PUBLIC	?divisionRemainder@@3HA				; divisionRemainder
PUBLIC	?factors@@3PAHA					; factors
PUBLIC	?startAddress@@3HA				; startAddress
PUBLIC	?lastIndexAddress@@3HA				; lastIndexAddress
PUBLIC	?factorCounter@@3HA				; factorCounter
PUBLIC	?sumFactors@@3HA				; sumFactors
PUBLIC	?programTitleMessage@@3PADA			; programTitleMessage
PUBLIC	??_C@_0GC@OLKDHKBA@Perfect?5Numbers?5?$CIbrute?9force?$CJ?6?9?9@ ; `string'
PUBLIC	?nextNumberMessage@@3PADA			; nextNumberMessage
PUBLIC	??_C@_0BG@LLEGLLKI@The?5next?5to?5test?5is?3?5?$AA@ ; `string'
PUBLIC	?perfectNumberMessage@@3PADA			; perfectNumberMessage
PUBLIC	??_C@_0BN@CCGHLFAG@?9?9?$DO?5Found?5a?5PERFECT?5NUMBER?3?5?$AA@ ; `string'
PUBLIC	?workingMessage@@3PADA				; workingMessage
PUBLIC	??_C@_06FDOGABHK@Sum?5?$DN?5?$AA@		; `string'
_BSS	SEGMENT
?divisionQuotient@@3HA DD 01H DUP (?)			; divisionQuotient
?divisionRemainder@@3HA DD 01H DUP (?)			; divisionRemainder
?factors@@3PAHA DD 01H DUP (?)				; factors
?startAddress@@3HA DD 01H DUP (?)			; startAddress
?lastIndexAddress@@3HA DD 01H DUP (?)			; lastIndexAddress
?factorCounter@@3HA DD 01H DUP (?)			; factorCounter
?sumFactors@@3HA DD 01H DUP (?)				; sumFactors
_BSS	ENDS
;	COMDAT ??_C@_06FDOGABHK@Sum?5?$DN?5?$AA@
CONST	SEGMENT
??_C@_06FDOGABHK@Sum?5?$DN?5?$AA@ DB 'Sum = ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CCGHLFAG@?9?9?$DO?5Found?5a?5PERFECT?5NUMBER?3?5?$AA@
CONST	SEGMENT
??_C@_0BN@CCGHLFAG@?9?9?$DO?5Found?5a?5PERFECT?5NUMBER?3?5?$AA@ DB '--> F'
	DB	'ound a PERFECT NUMBER: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LLEGLLKI@The?5next?5to?5test?5is?3?5?$AA@
CONST	SEGMENT
??_C@_0BG@LLEGLLKI@The?5next?5to?5test?5is?3?5?$AA@ DB 'The next to test '
	DB	'is: ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@OLKDHKBA@Perfect?5Numbers?5?$CIbrute?9force?$CJ?6?9?9@
CONST	SEGMENT
??_C@_0GC@OLKDHKBA@Perfect?5Numbers?5?$CIbrute?9force?$CJ?6?9?9@ DB 'Perf'
	DB	'ect Numbers (brute-force)', 0aH, '---------------------------'
	DB	'--', 0aH, '(After 8128 it will take a long time)', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
?numberFactor@@3HA DD 01H				; numberFactor
?programTitleMessage@@3PADA DD FLAT:??_C@_0GC@OLKDHKBA@Perfect?5Numbers?5?$CIbrute?9force?$CJ?6?9?9@ ; programTitleMessage
?nextNumberMessage@@3PADA DD FLAT:??_C@_0BG@LLEGLLKI@The?5next?5to?5test?5is?3?5?$AA@ ; nextNumberMessage
?perfectNumberMessage@@3PADA DD FLAT:??_C@_0BN@CCGHLFAG@?9?9?$DO?5Found?5a?5PERFECT?5NUMBER?3?5?$AA@ ; perfectNumberMessage
?workingMessage@@3PADA DD FLAT:??_C@_06FDOGABHK@Sum?5?$DN?5?$AA@ ; workingMessage
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	___local_stdio_scanf_options
PUBLIC	__vfprintf_l
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YGXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_printf
PUBLIC	__vfscanf_l
PUBLIC	_scanf
PUBLIC	?printChar@@YGXD@Z				; printChar
PUBLIC	?printStr@@YGXPAD@Z				; printStr
PUBLIC	?printInt@@YGXH@Z				; printInt
PUBLIC	_wmain
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0BG@NLOBLKOH@?6press?5enter?5to?5quit?6?$AA@ ; `string'
PUBLIC	??_C@_02HAOIJKIC@?$CFc?$AA@			; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vfscanf:PROC
EXTRN	__imp__malloc:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02HAOIJKIC@?$CFc?$AA@
CONST	SEGMENT
??_C@_02HAOIJKIC@?$CFc?$AA@ DB '%c', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NLOBLKOH@?6press?5enter?5to?5quit?6?$AA@
CONST	SEGMENT
??_C@_0BG@NLOBLKOH@?6press?5enter?5to?5quit?6?$AA@ DB 0aH, 'press enter t'
	DB	'o quit', 0aH, 00H				; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\goelm\desktop\assembler in vísual studio - perfect numbers cw\assembler in vusial studio - perfect numbers cw\start of stars cw\perfect numbers cw.cpp
;	COMDAT _wmain
_TEXT	SEGMENT
_dummy$ = -20						; size = 10
__$ArrayPad$ = -4					; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_wmain	PROC						; COMDAT

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 102  : 	// Allocate 1000 bytes in memory for the factors array:
; 103  : 	// A limitation of this program is that if it runs "forever" then it will 
; 104  : 	// eventually hit an issue with memory as with 1000 bytes of memory it can 
; 105  : 	// only store 250 factors of a number, the issue will only occur in very large
; 106  : 	// numbers but the memory allocated would have to be increased if it needs to 
; 107  : 	// handle factors of extremely large numbers.
; 108  : 	factors = (int *) malloc(1000); // I think that should cover it.

  00028	8b f4		 mov	 esi, esp
  0002a	68 e8 03 00 00	 push	 1000			; 000003e8H
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00035	83 c4 04	 add	 esp, 4
  00038	3b f4		 cmp	 esi, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	a3 00 00 00 00	 mov	 DWORD PTR ?factors@@3PAHA, eax ; factors

; 109  : 
; 110  : 
; 111  : 	//**********************************************************************//
; 112  : 	// Into assembler.														//
; 113  : 	// All the text in green after the "//" is a comment.  Comments are		//
; 114  : 	// purely for us humans to leave notes for ourselves; they are ignored	//
; 115  : 	// by the computer.														//
; 116  : 	//**********************************************************************//
; 117  : 	__asm
; 118  : 	{
; 119  : 
; 120  : 		// Print to console the program title.
; 121  : 		push [programTitleMessage]

  00044	ff 35 00 00 00
	00		 push	 DWORD PTR ?programTitleMessage@@3PADA ; programTitleMessage

; 122  : 		call printStr

  0004a	e8 00 00 00 00	 call	 ?printStr@@YGXPAD@Z	; printStr

; 123  : 		call printNewLine

  0004f	e8 2e 01 00 00	 call	 $printNewLine$6

; 124  : 		call printNewLine

  00054	e8 29 01 00 00	 call	 $printNewLine$6

; 125  : 
; 126  : 		//**************************************************************************
; 127  : 		// Move initial items into registers and the "C" variables for use. 
; 128  : 		// As we will be jumping from subroutines, we will not get a chance to 
; 129  : 		// otherwise initialise.
; 130  : 		//**************************************************************************
; 131  : 		
; 132  : 		// Store first memory location of array; each int is 4 bytes 
; 133  : 		// (we can use start address to help create a loop to place factors into the array).
; 134  : 		mov esi, [factors]

  00059	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?factors@@3PAHA ; factors

; 135  : 		mov startAddress, esi

  0005f	89 35 00 00 00
	00		 mov	 DWORD PTR ?startAddress@@3HA, esi ; startAddress

; 136  : 
; 137  : 		// TESTING: Print the start address.
; 138  : 		//mov al, 'S'
; 139  : 		//push al
; 140  : 		//call printChar
; 141  : 		//push startAddress
; 142  : 		//call printInt
; 143  : 		//call printNewLine
; 144  : 
; 145  : 		// The initial last index address is the start address as this is the last index used.
; 146  : 		mov lastIndexAddress, esi

  00065	89 35 00 00 00
	00		 mov	 DWORD PTR ?lastIndexAddress@@3HA, esi ; lastIndexAddress
$next_number_factor$7:

; 147  : 
; 148  : 
; 149  : 		//**********************************
; 150  : 		// Get the next number to calculate 
; 151  : 		// the factors of, the program always
; 152  : 		// returns back up to here.
; 153  : 		//**********************************
; 154  : 		next_number_factor: inc numberFactor

  0006b	ff 05 00 00 00
	00		 inc	 DWORD PTR ?numberFactor@@3HA ; numberFactor

; 155  : 
; 156  : 							// Print out the next number to test.
; 157  : 							// push [nextNumberMessage]
; 158  : 							// call printStr
; 159  : 							// push numberFactor
; 160  : 							// call printInt
; 161  : 							// call printNewLine
; 162  : 
; 163  : 							// Move the contents of the number we want to find factors
; 164  : 							// of into the factor counter, as we do this, we also put 
; 165  : 							// number we want to divide and find factors of into eax.
; 166  : 							mov eax, numberFactor

  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR ?numberFactor@@3HA ; numberFactor

; 167  : 							mov factorCounter, eax

  00076	a3 00 00 00 00	 mov	 DWORD PTR ?factorCounter@@3HA, eax ; factorCounter

; 168  : 
; 169  : 							cmp numberFactor, 1

  0007b	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?numberFactor@@3HA, 1 ; numberFactor

; 170  : 							je find_factors

  00082	74 07		 je	 SHORT $find_factors$8

; 171  : 							// Subtract to avoid having the 1 or the original number as a factor twice in the array.
; 172  : 							sub factorCounter, 1

  00084	83 2d 00 00 00
	00 01		 sub	 DWORD PTR ?factorCounter@@3HA, 1 ; factorCounter
$find_factors$8:

; 173  : 
; 174  : 
; 175  : 		//*****************************************************
; 176  : 		// Subroutine to find factors of the specified number.
; 177  : 		//*****************************************************
; 178  : 		find_factors: 
; 179  : 			    // Move the factor and counter into their rightful 
; 180  : 				// registers to prepare for the division.
; 181  : 				mov eax, numberFactor

  0008b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?numberFactor@@3HA ; numberFactor

; 182  : 				mov ebx, factorCounter

  00090	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?factorCounter@@3HA ; factorCounter

; 183  : 
; 184  : 				// Clear the edx register to allow for the remainder to be stored.
; 185  : 				mov edx, 0

  00096	ba 00 00 00 00	 mov	 edx, 0

; 186  : 
; 187  : 				// Divide the contents of eax by ebx.
; 188  : 				div ebx

  0009b	f7 f3		 div	 ebx

; 189  : 
; 190  : 				// Store the values of eax and edx safely in "C" variables.
; 191  : 				mov divisionQuotient, eax

  0009d	a3 00 00 00 00	 mov	 DWORD PTR ?divisionQuotient@@3HA, eax ; divisionQuotient

; 192  : 				mov divisionRemainder, edx

  000a2	89 15 00 00 00
	00		 mov	 DWORD PTR ?divisionRemainder@@3HA, edx ; divisionRemainder

; 193  : 
; 194  : 
; 195  : 				// TESTING: Print the divison information: factor counter, quotient, remainder.
; 196  : 				// Place any printing related calls here, 
; 197  : 				// otherwise we may disturb the contents of the CPU registers.
; 198  : 				// push factorCounter
; 199  : 				// call printInt
; 200  : 				// mov al, ','
; 201  : 				// push al
; 202  : 				// call printChar
; 203  : 				
; 204  : 				// push divisionQuotient
; 205  : 				// call printInt
; 206  : 				// mov al, ','
; 207  : 				// push al
; 208  : 				// call printChar
; 209  : 
; 210  : 				// push divisionRemainder
; 211  : 				// call printInt
; 212  : 				// call printNewLine
; 213  : 
; 214  : 
; 215  : 				// Save the factor counter from this operation to the factors array
; 216  : 				// if the division remainder was equal to 0, indicating a factor.
; 217  : 				cmp divisionRemainder, 0

  000a8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?divisionRemainder@@3HA, 0 ; divisionRemainder

; 218  : 				je save_factor

  000af	74 17		 je	 SHORT $save_factor$9
$backToFactors$10:

; 219  : 
; 220  : 				// A blank subroutine to allow us to carry on after jumping before.
; 221  : 				backToFactors:
; 222  : 
; 223  : 				// Decrement the factor counter.
; 224  : 				dec factorCounter

  000b1	ff 0d 00 00 00
	00		 dec	 DWORD PTR ?factorCounter@@3HA ; factorCounter

; 225  : 
; 226  : 				// Make a comparision to see if the factor counter has reached 0,
; 227  : 				// if it has exit the loop as we would have found the possible factors.
; 228  : 				cmp factorCounter, 0

  000b7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?factorCounter@@3HA, 0 ; factorCounter

; 229  : 				jnz find_factors

  000be	75 cb		 jne	 SHORT $find_factors$8

; 230  : 
; 231  : 				// Once we have found and saved the factors, we need to 
; 232  : 				// jump to finding the sum of the factors in the array.
; 233  : 				mov esi, lastIndexAddress  // Before we jump point the stack pointer to the last index address to help the loop.

  000c0	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?lastIndexAddress@@3HA ; lastIndexAddress

; 234  : 				jmp sum_all_factors

  000c6	eb 17		 jmp	 SHORT $sum_all_factors$11
$save_factor$9:

; 235  : 
; 236  : 
; 237  : 		//**********************************************
; 238  : 		// Subroutine to save each factor to the array.
; 239  : 		//**********************************************
; 240  : 		save_factor: add lastIndexAddress, 4

  000c8	83 05 00 00 00
	00 04		 add	 DWORD PTR ?lastIndexAddress@@3HA, 4 ; lastIndexAddress

; 241  : 
; 242  : 					 // TESTING: State the memory locations where we will save the factors in the array.
; 243  : 					 //mov al, 'M'
; 244  : 					 //push al
; 245  : 					 //call printChar
; 246  : 					 //push lastIndexAddress
; 247  : 					 //call printInt
; 248  : 					 //call printNewLine
; 249  : 
; 250  : 					 // As last index address is a "C" variable, it referring to what's in it will
; 251  : 					 // not get the equivalent value in stack, instead use ESI! This can change the last index value 
; 252  : 					 // to the factor itself, which will cause issues when trying to sum up the factors in the array.
; 253  : 					 // This was a major problem, only use ESI in brackets to get a value from the stack.
; 254  : 					 mov ecx, factorCounter

  000cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?factorCounter@@3HA ; factorCounter

; 255  : 					 mov esi, lastIndexAddress

  000d5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?lastIndexAddress@@3HA ; lastIndexAddress

; 256  : 					 mov [esi], ecx

  000db	89 0e		 mov	 DWORD PTR [esi], ecx

; 257  : 			
; 258  : 					 // TESTING: State that we have a found a factor along with 
; 259  : 					 //			 the actual factor we have found.
; 260  : 				     //push [foundFactorMessage]
; 261  : 					 //call printStr
; 262  : 					 //push [esi]
; 263  : 					 //call printInt
; 264  : 					 //call printNewLine
; 265  : 
; 266  : 					 // Allow us to jump back into the find_factors subroutine.
; 267  : 					 jmp backToFactors

  000dd	eb d2		 jmp	 SHORT $backToFactors$10
$sum_all_factors$11:

; 268  : 
; 269  : 
; 270  : 		//*****************************************
; 271  : 		// A subroutine to calculate the sum of the 
; 272  : 		// factors stored into the array.
; 273  : 		//*****************************************
; 274  : 		sum_all_factors: mov ecx, [esi]

  000df	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 275  : 						 add sumFactors, ecx

  000e1	01 0d 00 00 00
	00		 add	 DWORD PTR ?sumFactors@@3HA, ecx ; sumFactors

; 276  : 
; 277  : 						 // TESTING: Print the current value of the sum of the factors added.
; 278  : 						 //push sumMessage
; 279  : 					     //call printStr
; 280  : 						 //push sumFactors
; 281  : 						 //call printInt
; 282  : 						 //call printNewLine
; 283  : 
; 284  : 						 // Get to the next index by adding 4 to the memory location.
; 285  : 		 				 sub esi, 4

  000e7	83 ee 04	 sub	 esi, 4

; 286  : 
; 287  : 						 // Compare the what's in the current memory location to 0; a 0 means it is the 
; 288  : 						 // last index as nothing else has been stored in the array.
; 289  : 		 			     cmp esi, startAddress

  000ea	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?startAddress@@3HA ; startAddress

; 290  : 	                     jne sum_all_factors

  000f0	75 ed		 jne	 SHORT $sum_all_factors$11
$test_perfect_number$12:

; 291  : 
; 292  : 
; 293  : 		//*******************************************
; 294  : 		// This subroutine tests to see if the value
; 295  : 		// in the counter is a perfect number or not.
; 296  : 		//*******************************************
; 297  : 		test_perfect_number: //call printNewLine 
; 298  : 							 //push [sumFinalMessage]
; 299  : 		 			         //call printStr
; 300  : 		 				     //push sumFactors
; 301  : 							 //call printInt
; 302  : 							 //call printNewLine
; 303  : 
; 304  : 							 // Compare the number we were factorising to the sum to
; 305  : 						     // to determine if it is a perfect number or not.
; 306  : 					         mov eax, numberFactor

  000f2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?numberFactor@@3HA ; numberFactor

; 307  : 					         cmp eax, sumFactors

  000f7	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?sumFactors@@3HA ; sumFactors

; 308  : 
; 309  : 							 // If it is a perfect number, we can proceed with it's working.
; 310  : 							 je perfect_number_factors

  000fd	74 1b		 je	 SHORT $perfect_number_factors$13
$reset_and_return$14:

; 311  : 
; 312  :                              // Make sure we reset the memory addresses and sum variables to return 
; 313  : 							 // to the beginning for the next number.
; 314  : 							 reset_and_return:
; 315  : 
; 316  : 							 // Reset the last index address variable back to the start address for the next set of factors.
; 317  : 							 mov esi, startAddress

  000ff	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?startAddress@@3HA ; startAddress

; 318  : 							 mov lastIndexAddress, esi

  00105	89 35 00 00 00
	00		 mov	 DWORD PTR ?lastIndexAddress@@3HA, esi ; lastIndexAddress

; 319  : 							 // Reset the sumFactors variable, for the next set of factors.
; 320  : 							 mov sumFactors, 0

  0010b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?sumFactors@@3HA, 0 ; sumFactors

; 321  : 
; 322  : 							 // Jump to the next number to test.
; 323  : 							 jmp next_number_factor

  00115	e9 51 ff ff ff	 jmp	 $next_number_factor$7
$perfect_number_factors$13:

; 324  : 
; 325  : 
; 326  :         //****************************************************
; 327  : 		// This subroutine is for if the number we tested 
; 328  : 		// was a perfect number, this allows us to print 
; 329  : 		// the perfect number message and the working out
; 330  : 		// in order to make up the sum of the perfect number.
; 331  : 		//****************************************************
; 332  : 		perfect_number_factors: push[perfectNumberMessage]

  0011a	ff 35 00 00 00
	00		 push	 DWORD PTR ?perfectNumberMessage@@3PADA ; perfectNumberMessage

; 333  : 								call printStr

  00120	e8 00 00 00 00	 call	 ?printStr@@YGXPAD@Z	; printStr

; 334  : 								push numberFactor

  00125	ff 35 00 00 00
	00		 push	 DWORD PTR ?numberFactor@@3HA ; numberFactor

; 335  : 								call printInt

  0012b	e8 00 00 00 00	 call	 ?printInt@@YGXH@Z	; printInt

; 336  : 								call printNewLine

  00130	e8 4d 00 00 00	 call	 $printNewLine$6

; 337  : 
; 338  : 								push [workingMessage]

  00135	ff 35 00 00 00
	00		 push	 DWORD PTR ?workingMessage@@3PADA ; workingMessage

; 339  : 								call printStr

  0013b	e8 00 00 00 00	 call	 ?printStr@@YGXPAD@Z	; printStr

; 340  : 
; 341  : 								// In order to print the factors that make up the 
; 342  : 								// sum, we need to move the last index address into memory to 
; 343  : 								// reverse in the memory and print the factors.
; 344  : 								mov esi, lastIndexAddress

  00140	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?lastIndexAddress@@3HA ; lastIndexAddress

; 345  : 								jmp printSumFactors

  00146	eb 0c		 jmp	 SHORT $printSumFactors$15
$sum_printed$16:

; 346  : 
; 347  : 								sum_printed: call printNewLine

  00148	e8 35 00 00 00	 call	 $printNewLine$6

; 348  : 											 call printNewLine	

  0014d	e8 30 00 00 00	 call	 $printNewLine$6

; 349  : 
; 350  : 								// Jump back into the test_perfect_number subroutine.
; 351  :                                 jmp reset_and_return

  00152	eb ab		 jmp	 SHORT $reset_and_return$14
$printSumFactors$15:

; 352  : 
; 353  : 
; 354  : 		//***************************************************
; 355  : 		// Print the specific factors that make up the sum.
; 356  : 		//***************************************************
; 357  : 		printSumFactors: push [esi]

  00154	ff 36		 push	 DWORD PTR [esi]

; 358  : 						 call printInt

  00156	e8 00 00 00 00	 call	 ?printInt@@YGXH@Z	; printInt

; 359  : 
; 360  : 						 // In order to reverse, jump back 4 bytes to get 
; 361  : 						 // every integer value.
; 362  : 						 sub esi, 4

  0015b	83 ee 04	 sub	 esi, 4

; 363  : 
; 364  : 						 cmp esi, startAddress

  0015e	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?startAddress@@3HA ; startAddress

; 365  : 						 je skip_symbols

  00164	74 1a		 je	 SHORT $skip_symbols$17

; 366  : 						  
; 367  : 						 // Print the addition symbol in between the numbers for working out.
; 368  : 						 mov al, ' '

  00166	b0 20		 mov	 al, 32			; 00000020H

; 369  : 						 push al

  00168	50		 push	 eax

; 370  : 						 call printChar

  00169	e8 00 00 00 00	 call	 ?printChar@@YGXD@Z	; printChar

; 371  : 
; 372  : 						 mov al, '+'

  0016e	b0 2b		 mov	 al, 43			; 0000002bH

; 373  : 						 push al

  00170	50		 push	 eax

; 374  : 						 call printChar

  00171	e8 00 00 00 00	 call	 ?printChar@@YGXD@Z	; printChar

; 375  : 						 
; 376  : 						 mov al, ' '

  00176	b0 20		 mov	 al, 32			; 00000020H

; 377  : 						 push al

  00178	50		 push	 eax

; 378  : 						 call printChar

  00179	e8 00 00 00 00	 call	 ?printChar@@YGXD@Z	; printChar

; 379  : 
; 380  :                          // Jump back into this subroutine in the event there 
; 381  : 						 // are still more factors to print out.
; 382  : 						 jmp printSumFactors

  0017e	eb d4		 jmp	 SHORT $printSumFactors$15
$skip_symbols$17:

; 383  : 
; 384  : 					     // This will allow us to skip printing any unnecessary symbols 
; 385  : 						 // and head back up into the perfect_number_factors subroutine,
; 386  : 						 /// to reset and return back to the top to start the process again.
; 387  : 						 skip_symbols:
; 388  : 
; 389  : 						 jmp sum_printed

  00180	eb c6		 jmp	 SHORT $sum_printed$16
$printNewLine$6:

; 390  : 						 
; 391  : 						 
; 392  : 		//**********************************************************************//
; 393  : 		// This subroutine just makes one new line by printing the carriage		//
; 394  : 		// return and line feed characters.  Do we need both for a new line?  I //
; 395  : 		// think so...  Nigel.													//
; 396  : 		//																		//
; 397  : 		// No parameters go in.  Nothing comes back.							//
; 398  : 		//**********************************************************************//
; 399  : 		printNewLine: push '\r'			// Two lines to print a char.

  00182	6a 0d		 push	 13			; 0000000dH

; 400  : 					  call printChar

  00184	e8 00 00 00 00	 call	 ?printChar@@YGXD@Z	; printChar

; 401  : 
; 402  : 					  push '\n'		    // Two lines to print another char.

  00189	6a 0a		 push	 10			; 0000000aH

; 403  : 					  call printChar

  0018b	e8 00 00 00 00	 call	 ?printChar@@YGXD@Z	; printChar

; 404  : 
; 405  : 			          ret				// And back to <wherever we came from>

  00190	c3		 ret	 0
$finish$18:

; 406  : 
; 407  : 
; 408  : 
; 409  : 		//**********************************************************************//
; 410  : 		// Label to mark the end; do nothing, just jump here to finish.			//
; 411  : 		//**********************************************************************//
; 412  : 		finish:						// Do nothing			
; 413  : 	}
; 414  : 
; 415  : 
; 416  : 	//**********************************************************************//
; 417  : 	// Out of assembler.													//
; 418  : 	//**********************************************************************//
; 419  : 	printf("\npress enter to quit\n");

  00191	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@NLOBLKOH@?6press?5enter?5to?5quit?6?$AA@
  00196	e8 00 00 00 00	 call	 _printf
  0019b	83 c4 04	 add	 esp, 4

; 420  : 	char dummy[10];	     //Just in case several keys in buffer
; 421  : 	scanf("%c", dummy);  //pause.

  0019e	8d 45 ec	 lea	 eax, DWORD PTR _dummy$[ebp]
  001a1	50		 push	 eax
  001a2	68 00 00 00 00	 push	 OFFSET ??_C@_02HAOIJKIC@?$CFc?$AA@
  001a7	e8 00 00 00 00	 call	 _scanf
  001ac	83 c4 08	 add	 esp, 8

; 422  : 	scanf("%c", dummy);  //pause.  And once more.  Something weird going on.

  001af	8d 45 ec	 lea	 eax, DWORD PTR _dummy$[ebp]
  001b2	50		 push	 eax
  001b3	68 00 00 00 00	 push	 OFFSET ??_C@_02HAOIJKIC@?$CFc?$AA@
  001b8	e8 00 00 00 00	 call	 _scanf
  001bd	83 c4 08	 add	 esp, 8

; 423  : }

  001c0	52		 push	 edx
  001c1	8b cd		 mov	 ecx, ebp
  001c3	50		 push	 eax
  001c4	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@wmain
  001ca	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001cf	58		 pop	 eax
  001d0	5a		 pop	 edx
  001d1	5f		 pop	 edi
  001d2	5e		 pop	 esi
  001d3	5b		 pop	 ebx
  001d4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d7	33 cd		 xor	 ecx, ebp
  001d9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001de	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  001e4	3b ec		 cmp	 ebp, esp
  001e6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001eb	8b e5		 mov	 esp, ebp
  001ed	5d		 pop	 ebp
  001ee	c3		 ret	 0
  001ef	90		 npad	 1
$LN5@wmain:
  001f0	01 00 00 00	 DD	 1
  001f4	00 00 00 00	 DD	 $LN4@wmain
$LN4@wmain:
  001f8	ec ff ff ff	 DD	 -20			; ffffffecH
  001fc	0a 00 00 00	 DD	 10			; 0000000aH
  00200	00 00 00 00	 DD	 $LN3@wmain
$LN3@wmain:
  00204	64		 DB	 100			; 00000064H
  00205	75		 DB	 117			; 00000075H
  00206	6d		 DB	 109			; 0000006dH
  00207	6d		 DB	 109			; 0000006dH
  00208	79		 DB	 121			; 00000079H
  00209	00		 DB	 0
_wmain	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\goelm\desktop\assembler in vísual studio - perfect numbers cw\assembler in vusial studio - perfect numbers cw\start of stars cw\perfect numbers cw.cpp
;	COMDAT ?printInt@@YGXH@Z
_TEXT	SEGMENT
_someInt$ = 8						; size = 4
?printInt@@YGXH@Z PROC					; printInt, COMDAT

; 471  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 472  : 	printf("%d", someInt);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _someInt$[ebp]
  00021	50		 push	 eax
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00027	e8 00 00 00 00	 call	 _printf
  0002c	83 c4 08	 add	 esp, 8

; 473  : }	// we don't seee the "ret" instruction unless you view the ".cod" listing 

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?printInt@@YGXH@Z ENDP					; printInt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\goelm\desktop\assembler in vísual studio - perfect numbers cw\assembler in vusial studio - perfect numbers cw\start of stars cw\perfect numbers cw.cpp
;	COMDAT ?printStr@@YGXPAD@Z
_TEXT	SEGMENT
_strAddr$ = 8						; size = 4
?printStr@@YGXPAD@Z PROC				; printStr, COMDAT

; 452  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 453  : 	printf("%s", strAddr);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _strAddr$[ebp]
  00021	50		 push	 eax
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00027	e8 00 00 00 00	 call	 _printf
  0002c	83 c4 08	 add	 esp, 8

; 454  : }	// we don't seee the "ret" instruction unless you view the ".cod" listing 

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?printStr@@YGXPAD@Z ENDP				; printStr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\goelm\desktop\assembler in vísual studio - perfect numbers cw\assembler in vusial studio - perfect numbers cw\start of stars cw\perfect numbers cw.cpp
;	COMDAT ?printChar@@YGXD@Z
_TEXT	SEGMENT
_c$ = 8							; size = 1
?printChar@@YGXD@Z PROC					; printChar, COMDAT

; 439  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 440  : 	printf("%c", c);  //%c means as a char

  0001e	0f be 45 08	 movsx	 eax, BYTE PTR _c$[ebp]
  00022	50		 push	 eax
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_02HAOIJKIC@?$CFc?$AA@
  00028	e8 00 00 00 00	 call	 _printf
  0002d	83 c4 08	 add	 esp, 8

; 441  : 
; 442  : }	// we don't seee the "ret" instruction unless you view the ".cod" listing 

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
?printChar@@YGXD@Z ENDP					; printChar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT _scanf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Format$ = 8						; size = 4
_scanf	PROC						; COMDAT

; 1278 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1279 :         int _Result;
; 1280 :         va_list _ArgList;
; 1281 :         __crt_va_start(_ArgList, _Format);

  0001e	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QBD@@YGXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
  00023	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00026	89 45 ec	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1282 :         _Result = _vfscanf_l(stdin, _Format, NULL, _ArgList);

  00029	8b 45 ec	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0002c	50		 push	 eax
  0002d	6a 00		 push	 0
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Format$[ebp]
  00032	51		 push	 ecx
  00033	8b f4		 mov	 esi, esp
  00035	6a 00		 push	 0
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0003d	83 c4 04	 add	 esp, 4
  00040	3b f4		 cmp	 esi, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 __vfscanf_l
  0004d	83 c4 10	 add	 esp, 16			; 00000010H
  00050	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 1283 :         __crt_va_end(_ArgList);

  00053	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1284 :         return _Result;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 1285 :     }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_scanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT __vfscanf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfscanf_l PROC					; COMDAT

; 1060 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1061 :         return __stdio_common_vfscanf(

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ___local_stdio_scanf_options
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	51		 push	 ecx
  00039	8b 10		 mov	 edx, DWORD PTR [eax]
  0003b	52		 push	 edx
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfscanf
  00042	83 c4 18	 add	 esp, 24			; 00000018H
  00045	3b f4		 cmp	 esi, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1062 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 1063 :             _Stream, _Format, _Locale, _ArgList);
; 1064 :     }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
__vfscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 952  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 953  :         int _Result;
; 954  :         va_list _ArgList;
; 955  :         __crt_va_start(_ArgList, _Format);

  0001e	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QBD@@YGXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
  00023	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00026	89 45 ec	 mov	 DWORD PTR __ArgList$[ebp], eax

; 956  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00029	8b 45 ec	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0002c	50		 push	 eax
  0002d	6a 00		 push	 0
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Format$[ebp]
  00032	51		 push	 ecx
  00033	8b f4		 mov	 esi, esp
  00035	6a 01		 push	 1
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0003d	83 c4 04	 add	 esp, 4
  00040	3b f4		 cmp	 esi, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 __vfprintf_l
  0004d	83 c4 10	 add	 esp, 16			; 00000010H
  00050	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 957  :         __crt_va_end(_ArgList);

  00053	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 958  :         return _Result;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 959  :     }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YGXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YGXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 150  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 151  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 152  :         }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YGXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 640  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 641  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	51		 push	 ecx
  00039	8b 10		 mov	 edx, DWORD PTR [eax]
  0003b	52		 push	 edx
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  00042	83 c4 18	 add	 esp, 24			; 00000018H
  00045	3b f4		 cmp	 esi, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 642  :     }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 95   :         static unsigned __int64 _OptionsStorage;
; 96   :         return &_OptionsStorage;

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 97   :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 85   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 86   :         static unsigned __int64 _OptionsStorage;
; 87   :         return &_OptionsStorage;

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 88   :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
