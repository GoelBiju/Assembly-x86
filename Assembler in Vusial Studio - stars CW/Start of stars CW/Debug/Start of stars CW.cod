; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25508.2 

	TITLE	C:\Users\goelm\Desktop\Assembler in Vusial Studio - stars CW\Start of stars CW\Start of stars CW.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?numItems@@3HA					; numItems
PUBLIC	?items@@3PAHA					; items
PUBLIC	?anItem@@3HA					; anItem
PUBLIC	?startAddress@@3HA				; startAddress
PUBLIC	?endAddress@@3HA				; endAddress
PUBLIC	?itemCounter@@3HA				; itemCounter
PUBLIC	?starCounter@@3HA				; starCounter
_BSS	SEGMENT
?numItems@@3HA DD 01H DUP (?)				; numItems
?items@@3PAHA DD 01H DUP (?)				; items
?anItem@@3HA DD	01H DUP (?)				; anItem
?startAddress@@3HA DD 01H DUP (?)			; startAddress
?endAddress@@3HA DD 01H DUP (?)				; endAddress
?itemCounter@@3HA DD 01H DUP (?)			; itemCounter
?starCounter@@3HA DD 01H DUP (?)			; starCounter
_BSS	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	___local_stdio_scanf_options
PUBLIC	__vfprintf_l
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YGXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_printf
PUBLIC	__vfscanf_l
PUBLIC	_scanf
PUBLIC	?printChar@@YGXD@Z				; printChar
PUBLIC	?printStr@@YGXPAD@Z				; printStr
PUBLIC	?printInt@@YGXH@Z				; printInt
PUBLIC	_wmain
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0CG@GCHFCOLA@Enter?5item?5?$CFd?5?$CI0?5means?5end?5of?5da@ ; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_0BG@NLOBLKOH@?6press?5enter?5to?5quit?6?$AA@ ; `string'
PUBLIC	??_C@_02HAOIJKIC@?$CFc?$AA@			; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vfscanf:PROC
EXTRN	__imp__malloc:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02HAOIJKIC@?$CFc?$AA@
CONST	SEGMENT
??_C@_02HAOIJKIC@?$CFc?$AA@ DB '%c', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NLOBLKOH@?6press?5enter?5to?5quit?6?$AA@
CONST	SEGMENT
??_C@_0BG@NLOBLKOH@?6press?5enter?5to?5quit?6?$AA@ DB 0aH, 'press enter t'
	DB	'o quit', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GCHFCOLA@Enter?5item?5?$CFd?5?$CI0?5means?5end?5of?5da@
CONST	SEGMENT
??_C@_0CG@GCHFCOLA@Enter?5item?5?$CFd?5?$CI0?5means?5end?5of?5da@ DB 'Ent'
	DB	'er item %d (0 means end of data): ', 00H	; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\goelm\desktop\assembler in vusial studio - stars cw\start of stars cw\start of stars cw.cpp
;	COMDAT _wmain
_TEXT	SEGMENT
_dummy$ = -20						; size = 10
__$ArrayPad$ = -4					; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_wmain	PROC						; COMDAT

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 62   : 	// Allocate 1000 bytes in memory for the items array.
; 63   : 	items = (int *) malloc(1000); // I think that should cover it.

  00028	8b f4		 mov	 esi, esp
  0002a	68 e8 03 00 00	 push	 1000			; 000003e8H
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00035	83 c4 04	 add	 esp, 4
  00038	3b f4		 cmp	 esi, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	a3 00 00 00 00	 mov	 DWORD PTR ?items@@3PAHA, eax ; items

; 64   : 
; 65   : 
; 66   : 	//**********************************************************************//
; 67   : 	// As usual, we use "C" to do the heavy lifting and enter the numbers.
; 68   : 	// The do while loop halts when the user enters a 0, indicating the end 
; 69   : 	// of data entry.
; 70   : 	//**********************************************************************//
; 71   : 	numItems = 0;

  00044	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?numItems@@3HA, 0 ; numItems
$LN4@wmain:

; 72   : 	do
; 73   : 	{
; 74   : 		printf("Enter item %d (0 means end of data): ", numItems + 1);

  0004e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?numItems@@3HA ; numItems
  00053	83 c0 01	 add	 eax, 1
  00056	50		 push	 eax
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@GCHFCOLA@Enter?5item?5?$CFd?5?$CI0?5means?5end?5of?5da@
  0005c	e8 00 00 00 00	 call	 _printf
  00061	83 c4 08	 add	 esp, 8

; 75   : 		scanf("%d", &anItem);

  00064	68 00 00 00 00	 push	 OFFSET ?anItem@@3HA	; anItem
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  0006e	e8 00 00 00 00	 call	 _scanf
  00073	83 c4 08	 add	 esp, 8

; 76   : 		items[numItems] = anItem;

  00076	a1 00 00 00 00	 mov	 eax, DWORD PTR ?numItems@@3HA ; numItems
  0007b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?items@@3PAHA ; items
  00081	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?anItem@@3HA ; anItem
  00087	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 77   : 		numItems++;

  0008a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?numItems@@3HA ; numItems
  0008f	83 c0 01	 add	 eax, 1
  00092	a3 00 00 00 00	 mov	 DWORD PTR ?numItems@@3HA, eax ; numItems

; 78   : 
; 79   : 	} while (anItem != 0);

  00097	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?anItem@@3HA, 0 ; anItem
  0009e	75 ae		 jne	 SHORT $LN4@wmain

; 80   : 		
; 81   : 
; 82   : 
; 83   : 	//**********************************************************************//
; 84   : 	// Into assembler.														//
; 85   : 	// All the text in green after the "//" is a comment.  Comments are		//
; 86   : 	// purely for us humans to leave notes for ourselves; they are ignored	//
; 87   : 	// by the computer.														//
; 88   : 	//**********************************************************************//
; 89   : 	__asm
; 90   : 	{
; 91   : 
; 92   : 		//*************************************************************************
; 93   : 		// MULTIPLICATION EXAMPLE:
; 94   : 		// 
; 95   : 	    // NOTE: Multiplication answer and value the other register is multiplied by
; 96   : 		//		 is stored in eax.
; 97   : 		//   
; 98   : 		//		e.g. mov eax, 2
; 99   : 		//			 mov ebx, 2
; 100  : 		//			 
; 101  : 		//			 mul ebx
; 102  : 		//           push ebx
; 103  : 		//           call printInt
; 104  : 		//           jmp finish 
; 105  : 		//
; 106  : 		//  OUTPUT: 4
; 107  : 		//
; 108  : 		// We need to jump past the subroutine(s) that follow
; 109  : 		// else the CPU will just carry on going.
; 110  : 		//**************************************************************************
; 111  : 
; 112  : 
; 113  : 		//**************************************************************************
; 114  : 		// Move initial items into registers and the "C" variables for use. 
; 115  : 		// As we will be jumping from subroutines, we will not get a chance to 
; 116  : 		// otherwise initialise.
; 117  : 		//**************************************************************************
; 118  : 
; 119  : 		// Catch when there are no valid entry items (an item number of 1 will mean 
; 120  : 		// an entry of 0 was entered or an invalid entry was made). An entry of 0
; 121  : 		// can potentially create an infinite loop and is only for termination.
; 122  : 		cmp numItems, 1

  000a0	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?numItems@@3HA, 1 ; numItems

; 123  : 		jz finish

  000a7	0f 84 f1 00 00
	00		 je	 $finish$9

; 124  : 
; 125  : 		// Print some new lines separating the input and output of the program.
; 126  : 		call printNewLine

  000ad	e8 dd 00 00 00	 call	 $printNewLine$10

; 127  : 		call printNewLine

  000b2	e8 d8 00 00 00	 call	 $printNewLine$10

; 128  : 
; 129  : 		// Place the number of items we have into edx and from there move it into 
; 130  : 		// our item counter. We cannot move straight from a C variable to another C 
; 131  : 		// variable within the assembler without a register.
; 132  : 		mov edx, numItems

  000b7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?numItems@@3HA ; numItems

; 133  : 		mov itemCounter, edx

  000bd	89 15 00 00 00
	00		 mov	 DWORD PTR ?itemCounter@@3HA, edx ; itemCounter

; 134  : 
; 135  : 		// Pointer to the number in items, this will initially be the START ADDRESS.
; 136  : 		mov esi, [items]

  000c3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?items@@3PAHA ; items

; 137  : 
; 138  : 		// Store the first pointer address of the first item in the array (this can be used later if we need to).
; 139  : 		mov startAddress, esi

  000c9	89 35 00 00 00
	00		 mov	 DWORD PTR ?startAddress@@3HA, esi ; startAddress

; 140  : 
; 141  : 		// Calculate the end address of the last item in the array.
; 142  : 		mov eax, numItems

  000cf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?numItems@@3HA ; numItems

; 143  : 
; 144  : 		// 4 here represents the 4 bytes reserved for each integer.
; 145  : 		mov ebx, 4

  000d4	bb 04 00 00 00	 mov	 ebx, 4

; 146  : 
; 147  : 		// eax will now store the additional address from the start address to the end address.
; 148  : 		mul ebx     // gets whats in ebx and multiplies it with eax, and stores in eax.

  000d9	f7 e3		 mul	 ebx

; 149  : 		
; 150  : 		// Add the start address to the multiplication result in eax, which means the value
; 151  : 		// currently stored in eax is the final address of the last number item.
; 152  : 		add eax, startAddress

  000db	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?startAddress@@3HA ; startAddress

; 153  : 
; 154  : 		// Store what is in eax into the custom end address variable.
; 155  : 		mov endAddress, eax

  000e1	a3 00 00 00 00	 mov	 DWORD PTR ?endAddress@@3HA, eax ; endAddress

; 156  : 		
; 157  : 		// TESTING ONLY - To view the start address and the end address.
; 158  : 		//push startAddress
; 159  : 		//call printInt
; 160  : 		//call printNewLine
; 161  : 		//push endAddress
; 162  : 		//call printInt
; 163  : 		//call printNewLine
; 164  : 
; 165  : 		// Move the end address into esi before beginning.
; 166  : 		mov esi, endAddress

  000e6	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?endAddress@@3HA ; endAddress

; 167  : 
; 168  : 		//************************************************************************ 
; 169  : 		// Avoid the last 2 items (4 x 2 bytes) as they contain the end address 
; 170  : 		// zero which we do not need.
; 171  : 		sub esi, 8

  000ec	83 ee 08	 sub	 esi, 8

; 172  : 		//************************************************************************
; 173  : 
; 174  : 		//***********************************************************************
; 175  : 		// Adjust the numItems and item counter to discount the 0 at the end, 
; 176  : 		// as we do not print this to the console. Using dec will work, but to show 
; 177  : 		// that this is an intentional change, I will keep it using the sub opcode.
; 178  : 		//***********************************************************************
; 179  : 		sub numItems, 1

  000ef	83 2d 00 00 00
	00 01		 sub	 DWORD PTR ?numItems@@3HA, 1 ; numItems

; 180  : 		sub itemCounter, 1

  000f6	83 2d 00 00 00
	00 01		 sub	 DWORD PTR ?itemCounter@@3HA, 1 ; itemCounter
$reverse_items_stack$11:

; 181  : 
; 182  : 		//**********************************************************************//
; 183  : 		// Subroutimes start here, bits of code we want to execute more than	//
; 184  : 		// once, or just because we want to split a complicated task into several//
; 185  : 		// simpler ones.														//
; 186  : 		//**********************************************************************//
; 187  : 
; 188  : 		// What am I intending to do?
; 189  : 		// 
; 190  : 		// We will have to figure out the final address of the last item in the items array, 
; 191  : 		// then we can loop and subtract 4 for each item whilst maintaining a counter for the 
; 192  : 		// number of items originally entered (which will be decremented at the same time), 
; 193  : 		// we keep on subtracting 4 until we decrement all the way to 0.
; 194  : 
; 195  : 		reverse_items_stack: mov ecx, [esi]  // Move the next number item into the ecx register.

  000fd	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 196  : 
; 197  : 							 // Move the number of stars to output into the "C" star counter variable
; 198  : 							 // before we push the number in ecx into the stack.
; 199  : 							 mov starCounter, ecx

  000ff	89 0d 00 00 00
	00		 mov	 DWORD PTR ?starCounter@@3HA, ecx ; starCounter

; 200  : 
; 201  : 							 // REMEMBER: If you push an item onto the stack, make sure you print it out or pop it out 
; 202  : 							 //			 of the stack, otherwise you will encounter an ESP error.
; 203  : 							 // TESTING ONLY.
; 204  : 							 //push ecx
; 205  : 							 //call printInt
; 206  : 							 //call printNewLine
; 207  : 
; 208  : 							 // Print details regarding the graph; the data item number and padding.
; 209  : 							 jmp printGraphPadding	

  00105	eb 12		 jmp	 SHORT $printGraphPadding$12
$back$13:

; 210  : 
; 211  : 							 // A subroutine which acts as a way back due to the fact that we cannot 
; 212  : 							 // execute a conditional call, so we use a jmp at the end of the printGraphDetails.
; 213  : 							 back:
; 214  : 			
; 215  : 							 // Make a call to the subroutine allowing the stars to print.
; 216  : 							 call printStars

  00107	e8 42 00 00 00	 call	 $printStars$14

; 217  : 
; 218  : 							 // Compare to esi (current address) with the start address.
; 219  : 							 cmp esi, startAddress

  0010c	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?startAddress@@3HA ; startAddress

; 220  : 							 je printFinishingLine

  00112	74 57		 je	 SHORT $printFinishingLine$15

; 221  : 
; 222  : 							 // As integers are allocated 4 bytes in memory, subtract 4 from esi to get to previous 
; 223  : 							 // item in the data structure.
; 224  : 							 sub esi, 4

  00114	83 ee 04	 sub	 esi, 4

; 225  : 
; 226  : 							 // Jump unconditionally to items_into_stack to ensure we can print the next number.
; 227  : 							 jmp reverse_items_stack

  00117	eb e4		 jmp	 SHORT $reverse_items_stack$11
$printGraphPadding$12:

; 228  : 
; 229  : 
; 230  : 		//***********************************************
; 231  : 		// Work out the data item number and the padding 
; 232  : 		// it needs and then print the separator symbol.
; 233  : 		//***********************************************
; 234  : 		printGraphPadding: 
; 235  : 						   // Make sure padding is only needed when the number of items
; 236  : 						   // in total is greater than 10 (so we jump to printing details
; 237  : 						   // if it is anything below).
; 238  : 						   cmp numItems, 10

  00119	83 3d 00 00 00
	00 0a		 cmp	 DWORD PTR ?numItems@@3HA, 10 ; numItems, 0000000aH

; 239  : 						   jb printGraphDetails

  00120	72 11		 jb	 SHORT $printGraphDetails$16

; 240  : 
; 241  :                            // If the current item is greater or equal to 10,
; 242  : 						   // then we don't need to apply any padding.
; 243  : 						   cmp itemCounter, 10

  00122	83 3d 00 00 00
	00 0a		 cmp	 DWORD PTR ?itemCounter@@3HA, 10 ; itemCounter, 0000000aH

; 244  : 						   jae printGraphDetails

  00129	73 08		 jae	 SHORT $printGraphDetails$16

; 245  : 		
; 246  : 						   // Apply padding to the data item number; this will
; 247  : 						   // only apply in the case the conditions above won't be met,
; 248  : 						   // so the number of total items is greater than 9 and the current
; 249  : 						   // item number is less than 10.
; 250  : 						   mov al, ' '

  0012b	b0 20		 mov	 al, 32			; 00000020H

; 251  : 						   push al

  0012d	50		 push	 eax

; 252  : 						   call printChar

  0012e	e8 00 00 00 00	 call	 ?printChar@@YGXD@Z	; printChar
$printGraphDetails$16:

; 253  : 	
; 254  : 
; 255  : 		//**************************************
; 256  : 		// This subroutine allows the basic details 
; 257  : 		// of the each graph to be printed before
; 258  : 		// the actual stars are printed.
; 259  : 		//**************************************
; 260  : 		printGraphDetails: push itemCounter

  00133	ff 35 00 00 00
	00		 push	 DWORD PTR ?itemCounter@@3HA ; itemCounter

; 261  : 						   call printInt

  00139	e8 00 00 00 00	 call	 ?printInt@@YGXH@Z	; printInt

; 262  : 
; 263  : 						   // Subtract 1 from edx so that next time it will 
; 264  : 						   // display the appropriate data item number for the next number.
; 265  : 			               dec itemCounter

  0013e	ff 0d 00 00 00
	00		 dec	 DWORD PTR ?itemCounter@@3HA ; itemCounter

; 266  : 						   
; 267  : 						   // The separator symbol is moved into al 
; 268  : 					       // register and pushed to the stack to be 
; 269  : 						   // printed from the stack.
; 270  : 						   mov al, '|'

  00144	b0 7c		 mov	 al, 124			; 0000007cH

; 271  : 						   push al

  00146	50		 push	 eax

; 272  : 						   call printChar

  00147	e8 00 00 00 00	 call	 ?printChar@@YGXD@Z	; printChar

; 273  : 
; 274  : 						   // This jump is a fix to allow the program to
; 275  : 						   // work in the expected order, the program will head back
; 276  : 						   // to the empty subroutine allowing for it loop through again.
; 277  : 						   jmp back

  0014c	eb b9		 jmp	 SHORT $back$13
$printStars$14:

; 278  : 
; 279  : 
; 280  : 
; 281  : 		//******************************************
; 282  : 		// The subroutine prints stars based on the
; 283  : 		// the value set in the star counter.
; 284  : 		//******************************************
; 285  : 		printStars : mov al, '*'		

  0014e	b0 2a		 mov	 al, 42			; 0000002aH

; 286  : 					 push al

  00150	50		 push	 eax

; 287  : 					 call printChar

  00151	e8 00 00 00 00	 call	 ?printChar@@YGXD@Z	; printChar

; 288  : 
; 289  : 					 // Make sure we decrement the star counter and 
; 290  : 					 // check to make sure if it has reached 0 to 
; 291  : 					 // ret back to "reverse_items_stack" subroutine.
; 292  : 			         dec starCounter

  00156	ff 0d 00 00 00
	00		 dec	 DWORD PTR ?starCounter@@3HA ; starCounter

; 293  : 			         cmp starCounter, 0	

  0015c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?starCounter@@3HA, 0 ; starCounter

; 294  : 			         jne printStars

  00163	75 e9		 jne	 SHORT $printStars$14

; 295  : 
; 296  : 			         call printNewLine

  00165	e8 25 00 00 00	 call	 $printNewLine$10

; 297  : 			         
; 298  : 					 ret

  0016a	c3		 ret	 0
$printFinishingLine$15:

; 299  : 
; 300  : 
; 301  : 		//************************************
; 302  : 		// The subroutine allows for the final
; 303  : 		// line to print via the printStr 
; 304  : 		// function to finish the program.
; 305  : 		//************************************
; 306  : 		printFinishingLine:
; 307  : 							// Print the final line as a string by pushing the pointer to 
; 308  : 							// memory location of the string as defined as a "C" variable.
; 309  : 							// push [finishingLine]
; 310  : 						    mov esi, 0

  0016b	be 00 00 00 00	 mov	 esi, 0
$repeat_underscore$17:

; 311  : 
; 312  : 							repeat_underscore:
; 313  : 								mov al, '_'

  00170	b0 5f		 mov	 al, 95			; 0000005fH

; 314  : 								push al

  00172	50		 push	 eax

; 315  : 								call printChar

  00173	e8 00 00 00 00	 call	 ?printChar@@YGXD@Z	; printChar

; 316  : 							
; 317  : 								add esi, 1

  00178	83 c6 01	 add	 esi, 1

; 318  : 								cmp esi, 80

  0017b	83 fe 50	 cmp	 esi, 80			; 00000050H

; 319  : 								jne repeat_underscore

  0017e	75 f0		 jne	 SHORT $repeat_underscore$17

; 320  : 
; 321  : 							//
; 322  : 							mov al, '>'

  00180	b0 3e		 mov	 al, 62			; 0000003eH

; 323  : 							push al

  00182	50		 push	 eax

; 324  : 							call printChar

  00183	e8 00 00 00 00	 call	 ?printChar@@YGXD@Z	; printChar

; 325  : 
; 326  : 							//
; 327  : 							call printNewLine

  00188	e8 02 00 00 00	 call	 $printNewLine$10

; 328  : 							jmp finish

  0018d	eb 0f		 jmp	 SHORT $finish$9
$printNewLine$10:

; 329  : 
; 330  : 		
; 331  : 		//**********************************************************************//
; 332  : 		// This subroutine just makes one new line by printing the carriage		//
; 333  : 		// return and line feed characters.  Do we need both for a new line?  I //
; 334  : 		// think so...  Nigel.													//
; 335  : 		//																		//
; 336  : 		// No parameters go in.  Nothing comes back.							//
; 337  : 		//**********************************************************************//
; 338  : 		printNewLine: push '\r'			// Two lines to print a char.

  0018f	6a 0d		 push	 13			; 0000000dH

; 339  : 					  call printChar

  00191	e8 00 00 00 00	 call	 ?printChar@@YGXD@Z	; printChar

; 340  : 
; 341  : 					  push '\n'		    // Two lines to print another char.

  00196	6a 0a		 push	 10			; 0000000aH

; 342  : 					  call printChar

  00198	e8 00 00 00 00	 call	 ?printChar@@YGXD@Z	; printChar

; 343  : 
; 344  : 			          ret				// And back to <wherever we came from>

  0019d	c3		 ret	 0
$finish$9:

; 345  : 
; 346  : 
; 347  : 
; 348  : 		//**********************************************************************//
; 349  : 		// Label to mark the end; do nothing, just jump here to finish.			//
; 350  : 		//**********************************************************************//
; 351  : 		finish:						// Do nothing			
; 352  : 	}
; 353  : 
; 354  : 
; 355  : 	//**********************************************************************//
; 356  : 	// Out of assembler.													//
; 357  : 	//**********************************************************************//
; 358  : 	printf("\npress enter to quit\n");

  0019e	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@NLOBLKOH@?6press?5enter?5to?5quit?6?$AA@
  001a3	e8 00 00 00 00	 call	 _printf
  001a8	83 c4 04	 add	 esp, 4

; 359  : 	char dummy[10];	     //Just in case several keys in buffer
; 360  : 	scanf("%c", dummy);  //pause.

  001ab	8d 45 ec	 lea	 eax, DWORD PTR _dummy$[ebp]
  001ae	50		 push	 eax
  001af	68 00 00 00 00	 push	 OFFSET ??_C@_02HAOIJKIC@?$CFc?$AA@
  001b4	e8 00 00 00 00	 call	 _scanf
  001b9	83 c4 08	 add	 esp, 8

; 361  : 	scanf("%c", dummy);  //pause.  And once more.  Something weird going on.

  001bc	8d 45 ec	 lea	 eax, DWORD PTR _dummy$[ebp]
  001bf	50		 push	 eax
  001c0	68 00 00 00 00	 push	 OFFSET ??_C@_02HAOIJKIC@?$CFc?$AA@
  001c5	e8 00 00 00 00	 call	 _scanf
  001ca	83 c4 08	 add	 esp, 8

; 362  : }

  001cd	52		 push	 edx
  001ce	8b cd		 mov	 ecx, ebp
  001d0	50		 push	 eax
  001d1	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@wmain
  001d7	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001dc	58		 pop	 eax
  001dd	5a		 pop	 edx
  001de	5f		 pop	 edi
  001df	5e		 pop	 esi
  001e0	5b		 pop	 ebx
  001e1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e4	33 cd		 xor	 ecx, ebp
  001e6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001eb	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  001f1	3b ec		 cmp	 ebp, esp
  001f3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f8	8b e5		 mov	 esp, ebp
  001fa	5d		 pop	 ebp
  001fb	c3		 ret	 0
$LN8@wmain:
  001fc	01 00 00 00	 DD	 1
  00200	00 00 00 00	 DD	 $LN7@wmain
$LN7@wmain:
  00204	ec ff ff ff	 DD	 -20			; ffffffecH
  00208	0a 00 00 00	 DD	 10			; 0000000aH
  0020c	00 00 00 00	 DD	 $LN6@wmain
$LN6@wmain:
  00210	64		 DB	 100			; 00000064H
  00211	75		 DB	 117			; 00000075H
  00212	6d		 DB	 109			; 0000006dH
  00213	6d		 DB	 109			; 0000006dH
  00214	79		 DB	 121			; 00000079H
  00215	00		 DB	 0
_wmain	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\goelm\desktop\assembler in vusial studio - stars cw\start of stars cw\start of stars cw.cpp
;	COMDAT ?printInt@@YGXH@Z
_TEXT	SEGMENT
_someInt$ = 8						; size = 4
?printInt@@YGXH@Z PROC					; printInt, COMDAT

; 410  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 411  : 	printf("%d", someInt);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _someInt$[ebp]
  00021	50		 push	 eax
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00027	e8 00 00 00 00	 call	 _printf
  0002c	83 c4 08	 add	 esp, 8

; 412  : }	// we don't seee the "ret" instruction unless you view the ".cod" listing 

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?printInt@@YGXH@Z ENDP					; printInt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\goelm\desktop\assembler in vusial studio - stars cw\start of stars cw\start of stars cw.cpp
;	COMDAT ?printStr@@YGXPAD@Z
_TEXT	SEGMENT
_strAddr$ = 8						; size = 4
?printStr@@YGXPAD@Z PROC				; printStr, COMDAT

; 391  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 392  : 	printf("%s", strAddr);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _strAddr$[ebp]
  00021	50		 push	 eax
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00027	e8 00 00 00 00	 call	 _printf
  0002c	83 c4 08	 add	 esp, 8

; 393  : }	// we don't seee the "ret" instruction unless you view the ".cod" listing 

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?printStr@@YGXPAD@Z ENDP				; printStr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\goelm\desktop\assembler in vusial studio - stars cw\start of stars cw\start of stars cw.cpp
;	COMDAT ?printChar@@YGXD@Z
_TEXT	SEGMENT
_c$ = 8							; size = 1
?printChar@@YGXD@Z PROC					; printChar, COMDAT

; 378  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 379  : 	printf("%c", c);  //%c means as a char

  0001e	0f be 45 08	 movsx	 eax, BYTE PTR _c$[ebp]
  00022	50		 push	 eax
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_02HAOIJKIC@?$CFc?$AA@
  00028	e8 00 00 00 00	 call	 _printf
  0002d	83 c4 08	 add	 esp, 8

; 380  : 
; 381  : }	// we don't seee the "ret" instruction unless you view the ".cod" listing 

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
?printChar@@YGXD@Z ENDP					; printChar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT _scanf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Format$ = 8						; size = 4
_scanf	PROC						; COMDAT

; 1278 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1279 :         int _Result;
; 1280 :         va_list _ArgList;
; 1281 :         __crt_va_start(_ArgList, _Format);

  0001e	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QBD@@YGXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
  00023	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00026	89 45 ec	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1282 :         _Result = _vfscanf_l(stdin, _Format, NULL, _ArgList);

  00029	8b 45 ec	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0002c	50		 push	 eax
  0002d	6a 00		 push	 0
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Format$[ebp]
  00032	51		 push	 ecx
  00033	8b f4		 mov	 esi, esp
  00035	6a 00		 push	 0
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0003d	83 c4 04	 add	 esp, 4
  00040	3b f4		 cmp	 esi, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 __vfscanf_l
  0004d	83 c4 10	 add	 esp, 16			; 00000010H
  00050	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 1283 :         __crt_va_end(_ArgList);

  00053	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1284 :         return _Result;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 1285 :     }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_scanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT __vfscanf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfscanf_l PROC					; COMDAT

; 1060 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1061 :         return __stdio_common_vfscanf(

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ___local_stdio_scanf_options
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	51		 push	 ecx
  00039	8b 10		 mov	 edx, DWORD PTR [eax]
  0003b	52		 push	 edx
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfscanf
  00042	83 c4 18	 add	 esp, 24			; 00000018H
  00045	3b f4		 cmp	 esi, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1062 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 1063 :             _Stream, _Format, _Locale, _ArgList);
; 1064 :     }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
__vfscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 952  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 953  :         int _Result;
; 954  :         va_list _ArgList;
; 955  :         __crt_va_start(_ArgList, _Format);

  0001e	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QBD@@YGXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
  00023	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00026	89 45 ec	 mov	 DWORD PTR __ArgList$[ebp], eax

; 956  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00029	8b 45 ec	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0002c	50		 push	 eax
  0002d	6a 00		 push	 0
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Format$[ebp]
  00032	51		 push	 ecx
  00033	8b f4		 mov	 esi, esp
  00035	6a 01		 push	 1
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0003d	83 c4 04	 add	 esp, 4
  00040	3b f4		 cmp	 esi, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 __vfprintf_l
  0004d	83 c4 10	 add	 esp, 16			; 00000010H
  00050	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 957  :         __crt_va_end(_ArgList);

  00053	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 958  :         return _Result;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 959  :     }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YGXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YGXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 150  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 151  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 152  :         }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YGXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 640  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 641  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	51		 push	 ecx
  00039	8b 10		 mov	 edx, DWORD PTR [eax]
  0003b	52		 push	 edx
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  00042	83 c4 18	 add	 esp, 24			; 00000018H
  00045	3b f4		 cmp	 esi, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 642  :     }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 95   :         static unsigned __int64 _OptionsStorage;
; 96   :         return &_OptionsStorage;

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 97   :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 85   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 86   :         static unsigned __int64 _OptionsStorage;
; 87   :         return &_OptionsStorage;

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 88   :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
